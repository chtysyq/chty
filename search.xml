<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【51nod1693】水群]]></title>
    <url>%2F2017%2F04%2F22%2F1693%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 这题非常玄妙啊 首先简化题目，题面的意思就是，当前有一个数s 操作1是s*=k代价为k，操作2是s–代价为1 求把s从1变到n的最小代价 考虑把问题转化为图论模型，从i→i-1连一条权值为1的边，i→i*k连一条权值为k的边 在图上跑最短路即可 但是这样的话边数太多，时间会炸 我们考虑优化建图，注意到如果y=xij，那么从x连向y的边就可以用x-xi-xi*j这条路径代替 所以我们对于每个点i，只连i→i*p(p为质数)的边，这和原图是等价的 但是这样做复杂度依然会炸，题解上介绍了一种玄学方法： 打一个每个点自己最短路上的上一个点的表 那么可以从表中发现，i→i-1的边不会连续出现4次以上 而且i→i*p的边只有当p&lt;=13的时候才有意义 所以这样又可以删去很多边，于是就能通过此题 当然这道题的正解是记忆化搜索，但是我不会啊 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 2000010using namespace std;typedef pair&lt;int,int&gt;pii;const int prime[10]=&#123;0,2,3,5,7,11,13&#125;;const int cnt=6;struct node&#123;int y,next,v;&#125;e[MAXN&lt;&lt;1];int n,len,Link[MAXN],vis[MAXN],dis[MAXN];priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;void insert(int x,int y,int v)&#123;e[++len].next=Link[x];Link[x]=len;e[len].y=y;e[len].v=v;&#125;void pre()&#123; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=n+4;++j) insert(i,i*prime[j],prime[j]); for(int i=2;i&lt;=n+4;++i) insert(i,i-1,1);&#125;void dijkstra()&#123; memset(dis,10,sizeof(dis)); q.push(make_pair(0,1)); vis[1]=1; dis[1]=0; while(!q.empty())&#123; int v=q.top().first,x=q.top().second; q.pop(); for(int i=Link[x];i;i=e[i].next)&#123; if(dis[x]+e[i].v&lt;dis[e[i].y])&#123; dis[e[i].y]=dis[x]+e[i].v; if(!vis[e[i].y]) q.push(make_pair(dis[e[i].y],e[i].y)),vis[e[i].y]=1; &#125; &#125; vis[x]=0; &#125; printf("%d\n",dis[n]);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); pre(); dijkstra(); return 0;&#125;]]></content>
      <tags>
        <tag>51nod</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51nod1486】大大走格子]]></title>
    <url>%2F2017%2F04%2F21%2F1486%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 取出 k 个坏格，记 f[i] 表示从左上角不经过其它坏格，走到第 i 个坏格的方案数 考虑转移，走到 (x,y) 这个格，共有 C(x+y, x) 种方案 减掉不合法的，枚举第一次经过的坏格为 j f[i] -= f[j] * C(x[i]+y[i]-x[j]-y[j], x[i] - x[j]) 把终点也视为一个坏格，就能算方案数了 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define FILE "read"#define N 200000using namespace std;typedef long long ll;const ll mod=(ll)1e9+7;struct node&#123;ll x,y;&#125;p[2010];ll n,m,k,f[2010],inv[N+50],fac[N+50];inline ll read()&#123; ll x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;bool cmp(node a,node b)&#123;return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;ll fast(ll a,ll b)&#123;ll ret(1);for(;b;b&gt;&gt;=1,a=a*a%mod)if(b&amp;1)ret=ret*a%mod;return ret;&#125;ll C(ll n,ll m)&#123;return fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;void pre()&#123; fac[0]=1; for(ll i=1;i&lt;=N;++i) fac[i]=fac[i-1]*i%mod; inv[N]=fast(fac[N],mod-2); for(ll i=N-1;i&gt;=0;--i) inv[i]=inv[i+1]*(i+1)%mod;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read()-1; m=read()-1; k=read(); pre(); for(ll i=1;i&lt;=k;++i) p[i].x=read()-1,p[i].y=read()-1; p[++k].x=n; p[k].y=m; sort(p+1,p+k+1,cmp); for(ll i=1;i&lt;=k;++i)&#123; f[i]=C(p[i].x+p[i].y,p[i].x); for(ll j=1;j&lt;i;++j) if(p[i].y&gt;=p[j].y) (f[i]-=f[j]*C(p[i].x+p[i].y-p[j].x-p[j].y,p[i].x-p[j].x)%mod)%=mod; &#125; printf("%lld\n",(f[k]+mod)%mod); return 0;&#125;]]></content>
      <tags>
        <tag>51nod</tag>
        <tag>组合计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51nod1587】半现串]]></title>
    <url>%2F2017%2F04%2F21%2F1587%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 这是一种套路：用AC自动机+数位dp来统计某种必须出现的串或者不能出现的串的数量 首先我们把所有长度为d/2的串建成AC自动机 设$f[i][j][0/1]$表示前i位匹配到了AC自动机上的结点j是否匹配上的方案数 则$f[i][j][k]→f[i+1][tr[j][x]][k|tr[j][x]]$ （x为当前枚举数位上的数） 我用的是记忆化搜索，感觉记忆化搜索根本不用动脑子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define FILE "read"using namespace std;typedef long long ll;const int mod=(int)1e9+7;int n,d,cnt,num[55],vis[50010],fail[50010],tr[50010][10];ll ans,f[55][50010][2];char ch[1010],a[55],b[55],s[55];queue&lt;int&gt;q;inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;void extend()&#123; int now=0; for(int i=1;i&lt;=(d&gt;&gt;1);++i)&#123; if(!tr[now][s[i]-'0']) tr[now][s[i]-'0']=++cnt; now=tr[now][s[i]-'0']; &#125; vis[now]=1;&#125;void build()&#123; for(int i=0;i&lt;10;++i) if(tr[0][i]) q.push(tr[0][i]); while(!q.empty())&#123; int now=q.front(); q.pop(); for(int i=0;i&lt;10;++i)&#123; if(!tr[now][i]) tr[now][i]=tr[fail[now]][i]; else fail[tr[now][i]]=tr[fail[now]][i],q.push(tr[now][i]); &#125; &#125;&#125;ll dfs(int i,int j,int k,int flag)&#123; if(i==d+1) return k; if(!flag&amp;&amp;f[i][j][k]!=-1) return f[i][j][k]; ll ret=0; for(int x=0;x&lt;=(flag?num[i]:9);++x) (ret+=dfs(i+1,tr[j][x],k|vis[tr[j][x]],flag&amp;&amp;(x==num[i])))%=mod; if(!flag) f[i][j][k]=ret; return ret;&#125;bool check()&#123; int now=0,ret=0; for(int i=1;i&lt;=d;++i)&#123; now=tr[now][a[i]-'0']; ret|=vis[now]; &#125; return ret;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); scanf("%s%s%s",ch+1,a+1,b+1); n=strlen(ch+1); d=strlen(a+1); for(int i=1;i&lt;=n-(d&gt;&gt;1)+1;++i)&#123; for(int j=i;j&lt;=i+(d&gt;&gt;1)-1;++j) s[j-i+1]=ch[j]; extend(); &#125; build(); memset(f,-1,sizeof(f)); for(int i=1;i&lt;=d;++i) num[i]=b[i]-'0'; ans+=dfs(1,0,0,1); for(int i=1;i&lt;=d;++i) num[i]=a[i]-'0'; ans-=dfs(1,0,0,1); ans+=check(); ans=(ans%mod+mod)%mod; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>51nod</tag>
        <tag>AC自动机</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1123】BLO]]></title>
    <url>%2F2017%2F04%2F20%2F1123%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 求出割点，然后统计答案即可 做水题的感觉挺爽的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 100010#define MAXM 500010#define cmin(a,b) a=min(a,b)#define cmax(a,b) a=max(a,b)using namespace std;typedef long long ll;struct node&#123;int y,next;&#125;e[MAXM&lt;&lt;1];int n,m,len,dfs_clock,Link[MAXN],dfn[MAXN],low[MAXN],size[MAXN]; ll ans[MAXN];char buf[1&lt;&lt;15],*fs,*ft;inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125;inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f;&#125;void insert(int x,int y)&#123;e[++len].next=Link[x];Link[x]=len;e[len].y=y;&#125;void tarjan(int x)&#123; dfn[x]=low[x]=++dfs_clock; size[x]=1; int sum=0; for(int i=Link[x];i;i=e[i].next)&#123; if(!dfn[e[i].y])&#123; tarjan(e[i].y); cmin(low[x],low[e[i].y]); size[x]+=size[e[i].y]; if(low[e[i].y]&gt;=dfn[x])&#123; ans[x]+=(ll)size[e[i].y]*sum*2; sum+=size[e[i].y]; &#125; &#125; else cmin(low[x],dfn[e[i].y]); &#125; ans[x]+=(ll)sum*(n-sum-1)*2+(n-1)*2;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); m=read(); for(int i=1;i&lt;=m;++i)&#123; int x=read(),y=read(); insert(x,y); insert(y,x); &#125; tarjan(1); for(int i=1;i&lt;=n;++i) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51nod1469】淋漓尽致子串]]></title>
    <url>%2F2017%2F04%2F20%2F1469%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 首先建立后缀自动机,然后对于每个状态： 如果他的size为1，则这个状态不合法 如果他能转移到一个size&gt;1的状态，那么这个状态也不合法 如果他在parent树上有一个size&gt;1的孩子，那么这个状态也不合法 剩下的就是合法的，统计合法状态的数量就可以了 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 200010using namespace std;int n,ans,now(1),cnt(1),c[MAXN],id[MAXN],mx[MAXN],par[MAXN],Right[MAXN],vis[MAXN],son[MAXN][26];char ch[MAXN];void extend(int x)&#123; int np=++cnt,p=now; mx[np]=mx[p]+1; now=np; Right[np]=1; while(!son[p][x]&amp;&amp;p) son[p][x]=np,p=par[p]; if(!p) par[np]=1; else&#123; int q=son[p][x]; if(mx[q]==mx[p]+1) par[np]=q; else&#123; int nq=++cnt; mx[nq]=mx[p]+1; memcpy(son[nq],son[q],sizeof(son[q])); par[nq]=par[q]; par[q]=par[np]=nq; while(son[p][x]==q&amp;&amp;p) son[p][x]=nq,p=par[p]; &#125; &#125;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); scanf("%s",ch+1); n=strlen(ch+1); for(int i=1;i&lt;=n;++i) extend(ch[i]-'a'); for(int i=1;i&lt;=cnt;++i) c[mx[i]]++; for(int i=1;i&lt;=n;++i) c[i]+=c[i-1]; for(int i=1;i&lt;=cnt;++i) id[c[mx[i]]--]=i; for(int i=cnt;i;--i) Right[par[id[i]]]+=Right[id[i]]; Right[0]=0; for(int i=cnt;i;--i) if(Right[id[i]]&gt;1||vis[id[i]]) vis[par[id[i]]]=1; for(int i=1;i&lt;=cnt;++i) if(Right[i]&lt;=1) vis[i]=1; for(int i=1;i&lt;=cnt;++i)for(int j=0;j&lt;26;++j)if(Right[son[i][j]]&gt;1)vis[i]=1; for(int i=2;i&lt;=cnt;++i)if(!vis[i])ans++; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>51nod</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51nod1292】字符串中的最大值]]></title>
    <url>%2F2017%2F04%2F19%2F1292%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 这题是后缀自动机一眼题，但是我们有更简洁的方法解决它 我们回想kmp算法，一个串在进行自我匹配时j指针所在的位置正好是长度为j的前缀，每次匹配长度为j的前缀都被匹配上了一次 我们只需要记录每次j指针的位置，然后cnt[j]++就能统计次数 博主刚开始就是这么干的，结果样例都过不了 经过手玩推导，博主发现在长度为j的前缀被匹配到的同时，可能出现长度小于j的前缀也匹配到了的情况 博主不会处理这种情况于是去翻大佬题解 在某篇博客中提到了一个叫做next树的东西，就像AC自动机fail树一样，kmp中的next指针也形成了一棵树 所以要按照顺序沿着next树更新cnt数组，长知识了 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 1000010#define cmax(a,b) a=max(a,b)#define cmin(a,b) a=min(a,b)using namespace std;typedef long long ll;int n,pre[MAXN],cnt[MAXN];char ch[MAXN];int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); scanf("%s",ch+1); n=strlen(ch+1); ll ans=0; for(int i=2,j=0;i&lt;=n;++i)&#123; while(ch[j+1]!=ch[i]&amp;&amp;j) j=pre[j]; if(ch[j+1]==ch[i]) ++j; pre[i]=j; cnt[j]++; &#125; for(int i=n;i;--i)&#123; cmax(ans,(ll)(cnt[i]+1)*i); cnt[pre[i]]+=cnt[i]; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>51nod</tag>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1070】修车]]></title>
    <url>%2F2017%2F04%2F09%2F1070%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 我真是废了，这么水的题我居然没看出来是费用流 把每个人拆成n个点，表示次数即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 100010#define INF (int)1e9using namespace std;struct node&#123;int y,next,v,w;&#125;e[MAXN&lt;&lt;1];int n,m,S,T,cnt,ans,len(1),a[110][110],Link[MAXN],vis[MAXN],dis[MAXN],id[110][110],LN[MAXN],LE[MAXN],flow[MAXN];queue&lt;int&gt;q;inline int read()&#123; int x=0,f=1; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0') &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;void insert(int x,int y,int v,int w)&#123; e[++len].next=Link[x];Link[x]=len;e[len].y=y;e[len].v=v;e[len].w=w; e[++len].next=Link[y];Link[y]=len;e[len].y=x;e[len].v=0;e[len].w=-w;&#125;bool spfa()&#123; memset(vis,0,sizeof(vis)); memset(dis,10,sizeof(dis)); int oo=dis[0];q.push(S);dis[S]=0;vis[S]=1;flow[S]=INF; while(!q.empty())&#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=Link[x];i;i=e[i].next)if(dis[x]+e[i].w&lt;dis[e[i].y]&amp;&amp;e[i].v)&#123; dis[e[i].y]=dis[x]+e[i].w; flow[e[i].y]=min(flow[x],e[i].v); LN[e[i].y]=x; LE[e[i].y]=i; if(!vis[e[i].y]) q.push(e[i].y),vis[e[i].y]=1; &#125; &#125; if(dis[T]==oo) return 0; ans+=flow[T]*dis[T]; for(int i=T;i!=S;i=LN[i]) e[LE[i]].v-=flow[T],e[LE[i]^1].v+=flow[T]; return 1;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); m=read(); n=read(); S=++cnt; T=++cnt; for(int i=1;i&lt;=n;++i)for(int j=1;j&lt;=m;++j)a[i][j]=read(); for(int i=1;i&lt;=m;++i)for(int j=1;j&lt;=n;++j) id[i][j]=++cnt,insert(S,id[i][j],1,0); for(int i=1;i&lt;=n;++i)&#123; int x=++cnt; insert(x,T,1,0); for(int j=1;j&lt;=m;++j)for(int k=1;k&lt;=n;++k)insert(id[j][k],x,1,k*a[i][j]); &#125; while(spfa()); printf("%.2lf\n",(double)ans/n); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1084】最大子矩阵]]></title>
    <url>%2F2017%2F04%2F09%2F1084%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 刚看到题的时候我傻眼了，这东西不是npc问题吗 然后看到数据范围m&lt;=2，我*分类大讨论！ 当m=1时，显然 $f[i][j]=f[i-1][j]$ $f[i][j]=f[k][k-1]+sum[i]-sum[k]$ 当m=2是，状态要设成三维的 $f[i][j][k]=f[i-1][j][k],f[i][j-1][k]$ $f[i][j][k]=max(f[l][j][k-1]+sum[i][1]-sum[l][1],f[i][l][k-1]+sum[j][2]-sum[l][2])$ $f[i][j][k]=max(f[l][l][k-1],sum[i][1]+sum[j][2]-sum[l][1]-sum[l][2]) (i==j)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define FILE "read"#define INF (int)1e9#define cmax(a,b) a=max(a,b)#define cmin(a,b) a=min(a,b)using namespace std;int n,m,T,sum[110][5];inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;namespace solution1&#123; int f[110][110]; void solve()&#123; for(int i=0;i&lt;=n;++i)for(int j=1;j&lt;=T;++j)f[i][j]=-INF; for(int i=1;i&lt;=n;++i)for(int j=1;j&lt;=T;++j)&#123; f[i][j]=f[i-1][j]; for(int k=0;k&lt;i;++k) cmax(f[i][j],f[k][j-1]+sum[i][1]-sum[k][1]); &#125; printf("%d\n",f[n][T]); &#125;&#125;namespace solution2&#123; int f[110][110][110]; void solve()&#123; for(int i=0;i&lt;=n;++i)for(int j=0;j&lt;=n;++j)for(int k=1;k&lt;=T;++k)f[i][j][k]=-INF; for(int i=1;i&lt;=n;++i)for(int j=1;j&lt;=n;++j)for(int k=1;k&lt;=T;++k)&#123; f[i][j][k]=max(f[i-1][j][k],f[i][j-1][k]); for(int l=0;l&lt;i;++l) cmax(f[i][j][k],f[l][j][k-1]+sum[i][1]-sum[l][1]); for(int l=0;l&lt;j;++l) cmax(f[i][j][k],f[i][l][k-1]+sum[j][2]-sum[l][2]); if(i==j) for(int l=0;l&lt;i;++l) cmax(f[i][j][k],f[l][l][k-1]+sum[i][1]+sum[j][2]-sum[l][1]-sum[l][2]); &#125; printf("%d\n",f[n][n][T]); &#125;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); m=read(); T=read(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) sum[i][j]=sum[i-1][j]+read(); if(m==1) &#123; using namespace solution1; solve(); &#125; else&#123; using namespace solution2; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1492】货币兑换]]></title>
    <url>%2F2017%2F04%2F09%2F1492%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 建议阅读CDQ的论文《从Cash谈一类分治算法的应用》：传送门 这东西还挺好写的 注意：在计算左边对右边贡献时，必须保证左边是按f排序，右边是按k排序，由于f是现求的，所以在分治前必须先按k排序，归并时按f排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN (int)1e5+10#define eps 1e-8#define cmin(a,b) a=min(a,b)#define cmax(a,b) a=max(a,b)using namespace std;struct node&#123; double a,b,rate,x,y,k; int id; bool operator &lt; (const node z)const &#123;return k&gt;z.k;&#125;&#125;p[MAXN],sta[MAXN];int n,st[MAXN];double f[MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;double slop(int a,int b)&#123; if(!b)return -1e20; if(fabs(p[a].x-p[b].x)&lt;eps)return 1e20; return (p[b].y-p[a].y)/(p[b].x-p[a].x);&#125;void solve(int l,int r)&#123; if(l==r)&#123; cmax(f[l],f[l-1]); p[l].x=f[l]*p[l].rate/(p[l].a*p[l].rate+p[l].b); p[l].y=p[l].x/p[l].rate; return; &#125; int mid=(l+r)&gt;&gt;1,ta=l,tb=mid+1,top=0,j=1; for(int i=l;i&lt;=r;++i)&#123; if(p[i].id&lt;=mid) sta[ta++]=p[i]; else sta[tb++]=p[i]; &#125; for(int i=l;i&lt;=r;++i) p[i]=sta[i]; solve(l,mid); for(int i=l;i&lt;=mid;++i)&#123; while(top&gt;1&amp;&amp;slop(i,st[top])+eps&gt;slop(st[top],st[top-1])) --top; st[++top]=i; &#125;st[++top]=0; for(int i=mid+1;i&lt;=r;++i)&#123; while(j&lt;top&amp;&amp;slop(st[j],st[j+1])+eps&gt;p[i].k) ++j; cmax(f[p[i].id],p[st[j]].x*p[i].a+p[st[j]].y*p[i].b); &#125; solve(mid+1,r); ta=l; tb=mid+1; for(int i=l;i&lt;=r;++i)&#123; if((p[ta].x&lt;p[tb].x||(abs(p[ta].x-p[tb].x)&lt;eps)&amp;&amp;p[ta].y&lt;p[tb].y||tb&gt;r)&amp;&amp;ta&lt;=mid) sta[i]=p[ta++]; else sta[i]=p[tb++]; &#125; for(int i=l;i&lt;=r;++i) p[i]=sta[i];&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); f[0]=read(); for(int i=1;i&lt;=n;++i)&#123; scanf("%lf%lf%lf",&amp;p[i].a,&amp;p[i].b,&amp;p[i].rate); p[i].id=i; p[i].k=-p[i].a/p[i].b; &#125; sort(p+1,p+n+1); solve(1,n); printf("%.3lf\n",f[n]); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>斜率优化</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1855】股票交易]]></title>
    <url>%2F2017%2F04%2F09%2F1855%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 设f[i][j]表示第i天拥有j股股票的最大收益 首先列出朴素的状态转移方程： $f[i][j]=f[i-1][j]$ $f[i][j]=max{f[i-w-1][k]-(j-k)\times A[i]} (k&gt;=j-AS[i])$ $f[i][j]=max{f[i-w-1][k]+(k-j)\times B[i]} (k&lt;=max(MaxP,AS[i]+j))$ 然后我们发现可以用单调队列维护$f[i-w-1][k]+k\times A[i]$和$f[i-w-1][k]+k\times B[i]$ 这样就能把复杂度降到O(n^2) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 2010#define cmax(a,b) a=max(a,b)#define cmin(a,b) a=min(a,b)using namespace std;int n,maxp,w,ans,a[MAXN],b[MAXN],as[MAXN],bs[MAXN],q[MAXN],f[MAXN][MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;int main()&#123; //freopen(FILE".in","r",stdin); //freopen(FILE".out","w",stdout); n=read(); maxp=read(); w=read(); memset(f,-10,sizeof(f)); for(int i=1;i&lt;=n;++i) a[i]=read(),b[i]=read(),as[i]=read(),bs[i]=read(); for(int i=1;i&lt;=n;++i)&#123; for(int j=0;j&lt;=as[i];j++) f[i][j]=-a[i]*j; for(int j=0;j&lt;=maxp;++j) cmax(f[i][j],f[i-1][j]); if(i-w-1&lt;0) continue; int head=0,tail=0; for(int j=0;j&lt;=maxp;++j)&#123; while(head&lt;tail&amp;&amp;q[head]&lt;j-as[i]) ++head; while(head&lt;tail&amp;&amp;f[i-w-1][j]+j*a[i]&gt;=f[i-w-1][q[tail-1]]+q[tail-1]*a[i]) --tail; q[tail++]=j; if(head&lt;tail) cmax(f[i][j],f[i-w-1][q[head]]-a[i]*(j-q[head])); &#125; head=0,tail=0; for(int j=maxp;j&gt;=0;--j)&#123; while(head&lt;tail&amp;&amp;q[head]&gt;j+bs[i]) ++head; while(head&lt;tail&amp;&amp;f[i-w-1][j]+j*b[i]&gt;=f[i-w-1][q[tail-1]]+q[tail-1]*b[i]) --tail; q[tail++]=j; if(head&lt;tail) cmax(f[i][j],f[i-w-1][q[head]]+b[i]*(q[head]-j)); &#125; &#125; for(int i=0;i&lt;=maxp;++i) cmax(ans,f[n][i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>单调性优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2442】修剪草坪]]></title>
    <url>%2F2017%2F04%2F05%2F2442%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 f[i]=max{f[j]+sum[i]-sum[j+1]} (i-j-1&lt;=k) 这个式子可以用单调性来优化 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 100010using namespace std;typedef long long ll;ll n,k,head,tail,a[MAXN],sum[MAXN],f[MAXN],q[MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); k=read(); for(int i=1;i&lt;=n;++i) a[i]=read(),sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=n;++i)&#123; while(head&lt;tail&amp;&amp;i-q[head]-1&gt;k) ++head; if(i&lt;=k) f[i]=sum[i]; else f[i]=f[q[head]]+sum[i]-sum[q[head]+1]; while(head&lt;tail&amp;&amp;f[i]-sum[i+1]&gt;=f[q[tail]]-sum[q[tail]+1]) --tail; q[++tail]=i; &#125; printf("%lld\n",f[n]); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>单调性优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1799】同类分布]]></title>
    <url>%2F2017%2F04%2F02%2F1799%2F</url>
    <content type="text"><![CDATA[数位dp重修系列第二题 AC通道 这道题方法很妙，get到了一些经验 我们发现数位之和在1~162的范围内，所以可以直接枚举数位和sum 然后用f[i][j][k]记录前i位的数位和为j，且当前数模sum等于k，那么判断合法的条件就是j==sum&amp;&amp;k==0 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define FILE "read"using namespace std;typedef long long ll;int sum,num[20];ll ans,f[20][170][170];inline ll read()&#123; ll x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;ll dfs(int i,int j,int k,int flag)&#123; if(j&gt;sum) return 0; if(!i) return (j==sum&amp;&amp;!k); if(!flag&amp;&amp;f[i][j][k]!=-1) return f[i][j][k]; ll temp=0; for(int x=0;x&lt;=(flag?num[i]:9);++x) temp+=dfs(i-1,j+x,(k*10+x)%sum,flag&amp;&amp;x==num[i]); if(!flag) f[i][j][k]=temp; return temp;&#125;ll cal(ll x)&#123; int tot=0; memset(f,-1,sizeof(f)); while(x) num[++tot]=x%10,x/=10; if(tot*9&lt;sum) return 0; return dfs(tot,0,0,1);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); ll l=read(),r=read(); for(int i=1;i&lt;=162;++i) sum=i,ans+=cal(r)-cal(l-1); printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1088】扫雷Mine]]></title>
    <url>%2F2017%2F03%2F31%2F1088%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 随机程序又摇出了一道水题，好开心啊 我们发现只要确定了前2个格子是否有雷，就可以确定整列的状态 模拟即可 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 10010using namespace std;int n,ans,a[MAXN],f[MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;int check()&#123; for(int i=3;i&lt;=n;++i)&#123; f[i]=a[i-1]-f[i-1]-f[i-2]; if(f[i]&lt;0||f[i]&gt;1) return 0; &#125; if(a[n]!=f[n]+f[n-1]) return 0; return 1;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); if(a[1]==0) ans+=check(); else if(a[1]==1)&#123; f[1]=1; ans+=check(); memset(f,0,sizeof(f)); f[2]=1; ans+=check(); &#125; else f[1]=f[2]=1,ans+=check(); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2096】Pilots]]></title>
    <url>%2F2017%2F03%2F28%2F2096%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载\ AC通道 这题显然使用双指针扫描一遍，然后的问题就是维护区间的最大值和最小值 用线段树可以做到$O(n\log n)$，但是此题的数据范围不支持 考虑用单调队列维护，方法同单调队列经典例题window 感谢cdcq同学帮我查错 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define FILE "read"#define MAXN 3000010#define cmin(a,b) a=min(a,b)#define cmax(a,b) a=max(a,b)int n,k,ans,cur(1),a[MAXN],head[3],tail[3],q[3][MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); k=read(); n=read(); head[1]=head[2]=1; for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i)&#123; while(a[i]&gt;a[q[1][tail[1]]]&amp;&amp;head[1]&lt;=tail[1]) tail[1]--; while(a[i]&lt;a[q[2][tail[2]]]&amp;&amp;head[2]&lt;=tail[2]) tail[2]--; q[1][++tail[1]]=i; q[2][++tail[2]]=i; while(a[q[1][head[1]]]-a[q[2][head[2]]]&gt;k)&#123; if(cur==q[1][head[1]]&amp;&amp;head[1]&lt;=tail[1]) ++head[1]; if(cur==q[2][head[2]]&amp;&amp;head[2]&lt;=tail[2]) ++head[2]; ++cur; &#125; cmax(ans,i-cur+1); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HAOI2013】软件安装]]></title>
    <url>%2F2017%2F03%2F20%2F1365%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 这道题一眼线段树，秒水题真是爽啊 然而还是调了2个小时。。。。。。 我们只需要用线段树维护lx,rx,maxx，分别表示区间的左起连续0的个数，右起连续的0的个数，最大的连续0的个数，就可以实现区间信息的合并。 坑点：标记必须提前下传，因为回答询问时需要用到子节点信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define FILE "read"#define MAXN 50010using namespace std;struct node&#123;int lx,rx,maxx,tag;&#125;tr[MAXN&lt;&lt;3];char buf[1&lt;&lt;15],*fs,*ft;inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin)),fs==ft)?0:*fs++;&#125;inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f;&#125;void relord(int p,int l,int r)&#123; if(tr[p].tag==0) tr[p].lx=tr[p].rx=tr[p].maxx=r-l+1; else if(tr[p].tag==1) tr[p].lx=tr[p].rx=tr[p].maxx=0;&#125;void pushdown(int p,int l,int r)&#123; if(tr[p].tag==-1) return; int mid=(l+r)&gt;&gt;1; tr[p&lt;&lt;1].tag=tr[p&lt;&lt;1|1].tag=tr[p].tag; relord(p&lt;&lt;1,l,mid); relord(p&lt;&lt;1|1,mid+1,r); tr[p].tag=-1;&#125;void pushup(int p,int l,int r)&#123; tr[p].maxx=max(tr[p&lt;&lt;1].maxx,max(tr[p&lt;&lt;1|1].maxx,tr[p&lt;&lt;1].rx+tr[p&lt;&lt;1|1].lx)); int mid=(l+r)&gt;&gt;1; if(tr[p&lt;&lt;1].lx==mid-l+1) tr[p].lx=tr[p&lt;&lt;1].lx+tr[p&lt;&lt;1|1].lx; else tr[p].lx=tr[p&lt;&lt;1].lx; if(tr[p&lt;&lt;1|1].rx==r-mid) tr[p].rx=tr[p&lt;&lt;1|1].rx+tr[p&lt;&lt;1].rx; else tr[p].rx=tr[p&lt;&lt;1|1].rx;&#125;int ask(int p,int l,int r,int x)&#123; pushdown(p,l,r); if(l==r) return l; int mid=(l+r)&gt;&gt;1; if(tr[p&lt;&lt;1].maxx&gt;=x) return ask(p&lt;&lt;1,l,mid,x); if(tr[p&lt;&lt;1].rx+tr[p&lt;&lt;1|1].lx&gt;=x) return mid-tr[p&lt;&lt;1].rx+1; return ask(p&lt;&lt;1|1,mid+1,r,x);&#125;void updata(int p,int l,int r,int x,int y,int v)&#123; pushdown(p,l,r); if(x&lt;=l&amp;&amp;y&gt;=r) &#123;tr[p].tag=v; relord(p,l,r); return;&#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=y) updata(p&lt;&lt;1,l,mid,x,y,v); else if(mid&lt;x) updata(p&lt;&lt;1|1,mid+1,r,x,y,v); else&#123; updata(p&lt;&lt;1,l,mid,x,mid,v); updata(p&lt;&lt;1|1,mid+1,r,mid+1,y,v); &#125; pushup(p,l,r);&#125;void build(int p,int l,int r)&#123; pushdown(p,l,r); if(l==r) return; int mid=(l+r)&gt;&gt;1; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); int n=read(),m=read(); relord(1,1,n); build(1,1,n); for(int i=1;i&lt;=m;++i)&#123; int opt=read(),x=read(); if(opt==1)&#123; if(tr[1].maxx&gt;=x)&#123; int t=ask(1,1,n,x); updata(1,1,n,t,t+x-1,1); printf("%d\n",t); &#125; else puts("0"); &#125; else&#123;int y=read();updata(1,1,n,x,x+y-1,0);&#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1023】cactus仙人掌图]]></title>
    <url>%2F2017%2F03%2F19%2F1023%2F</url>
    <content type="text"><![CDATA[仙人掌系列第一题 AC通道 求仙人掌直径，仙人掌经典问题之一。 在仙人掌上做dp即可。 错误记录：dfs缩环过程变量名打错，查了一个小时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define FILE "read"#define MAXN 100010#define cmax(a,b) a=max(a,b)#define cmin(a,b) a=min(a,b)using namespace std;struct node&#123;int y,next,v;&#125;e[MAXN&lt;&lt;2];int n,m,cnt,bcnt,top,ans,dfs_clock,len(1),Link[MAXN],dfn[MAXN],f[MAXN],lenth[MAXN],dis[MAXN],q[MAXN&lt;&lt;1],p[MAXN&lt;&lt;1];vector&lt;int&gt;ring[MAXN&lt;&lt;2];char buf[1&lt;&lt;15],*fs,*ft;inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125;inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f;&#125;void insert(int x,int y,int v)&#123; e[++len].next=Link[x];Link[x]=len;e[len].y=y;e[len].v=v; e[++len].next=Link[y];Link[y]=len;e[len].y=x;e[len].v=v;&#125;void dfs(int x,int fa)&#123; dfn[x]=++dfs_clock; for(int i=Link[x];i;i=e[i].next)if(e[i].y!=fa)&#123; if(!dfn[e[i].y]) q[++top]=i,dfs(e[i].y,x),--top; else if(dfn[e[i].y]&lt;dfn[x])&#123; ring[++bcnt].push_back(i); for(int j=top;j;--j)&#123; if(e[q[j]].y==e[i].y) break; ring[bcnt].push_back(q[j]); &#125; &#125; &#125;&#125;void build()&#123; for(int k=1;k&lt;=bcnt;++k)&#123; int size=ring[k].size(),top=e[ring[k][0]].y; for(int i=0;i&lt;size;++i)&#123; int temp=e[ring[k][i]].y; lenth[k]+=e[ring[k][i]].v; dis[i+1]=lenth[k]; e[ring[k][i]].y=e[ring[k][i]^1].y=0; ring[k][i]=temp; &#125;insert(++cnt,top,0); for(int i=1;i&lt;size;++i) insert(ring[k][i],cnt,min(dis[i],lenth[k]-dis[i])); &#125;&#125;void dp(int x,int fa)&#123; for(int i=Link[x];i;i=e[i].next)if(e[i].y&amp;&amp;e[i].y!=fa)&#123; dp(e[i].y,x); if(x&lt;=n) cmax(ans,f[x]+f[e[i].y]+e[i].v); cmax(f[x],f[e[i].y]+e[i].v); &#125;&#125;void dp()&#123; for(int k=1;k&lt;=bcnt;++k)&#123; int size=ring[k].size(),top=ring[k][0],temp=f[top];f[top]=0; for(int i=0;i&lt;size;++i) p[i+1]=p[i+size+1]=ring[k][i]; for(int i=1,head=1,tail=0;i&lt;=size*2;++i)&#123; while(head&lt;=tail&amp;&amp;i-q[head]&gt;(size&gt;&gt;1)) ++head; if(head&lt;=tail) cmax(ans,i-q[head]+f[p[i]]+f[p[q[head]]]); while(head&lt;=tail&amp;&amp;f[p[q[tail]]]-q[tail]&lt;=f[p[i]]-i) --tail; q[++tail]=i; &#125;f[top]=temp; &#125;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=cnt=read(); m=read(); for(int i=1;i&lt;=m;++i)&#123; int T=read(),temp=read(); for(int j=1,t;j&lt;T;++j) insert((t=read()),temp,1),temp=t; &#125; dfs(1,0); build(); dp(1,0); dp(); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>仙人掌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2229】最小割]]></title>
    <url>%2F2017%2F03%2F15%2F2229%2F</url>
    <content type="text"><![CDATA[分治最小割系列第一题 AC通道 分治最小割算法，用于求最小割树，即本质不同的最小割组成的树 结论如下：一张n个节点的图最多有有n-1个本质不同的最小割（我不会证明） 我也不知道这样做为什么是正确的，网上找不到任何证明资料 不过在OI界，证明是用来装逼的，会做题就行了吧QAQ 这里get到一个小技巧：令len的初值为1，就能用i^1求出i的反向边编号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 350#define INF 1000000000using namespace std;struct node&#123;int y,next,v;&#125;e[6010];int n,m,len,S,T,Link[MAXN],a[MAXN],vis[MAXN],level[MAXN],temp[MAXN],val[MAXN][MAXN];queue&lt;int&gt;q;char buf[1&lt;&lt;15],*fs,*ft;inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125;inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f;&#125;void insert(int x,int y,int v)&#123;e[++len].next=Link[x];Link[x]=len;e[len].y=y;e[len].v=v;&#125;void dfs(int x)&#123; vis[x]=1; for(int i=Link[x];i;i=e[i].next) if(e[i].v&amp;&amp;!vis[e[i].y]) dfs(e[i].y);&#125;bool bfs()&#123; memset(level,-1,sizeof(level)); q.push(S); level[S]=0; while(!q.empty())&#123; int x=q.front(); q.pop(); for(int i=Link[x];i;i=e[i].next) if(level[e[i].y]==-1&amp;&amp;e[i].v)&#123; q.push(e[i].y); level[e[i].y]=level[x]+1; &#125; &#125; return level[T]&gt;=0;&#125;int MAXFLOW(int x,int flow)&#123; if(x==T) return flow; int d=0,maxflow=0; for(int i=Link[x];i&amp;&amp;maxflow&lt;flow;i=e[i].next) if(level[e[i].y]==level[x]+1&amp;&amp;e[i].v) if(d=MAXFLOW(e[i].y,min(e[i].v,flow-maxflow))) e[i].v-=d,e[i^1].v+=d,maxflow+=d; if(!maxflow) level[x]=-1; return maxflow;&#125;void solve(int l,int r)&#123; if(l==r) return; S=a[l]; T=a[r]; int d=0,ans=0; for(int i=1;i&lt;=len;++i) e[i].v=e[i^1].v=(e[i].v+e[i^1].v)&gt;&gt;1; while(bfs()) while(d=MAXFLOW(S,INF)) ans+=d; memset(vis,0,sizeof(vis)); dfs(S); for(int i=1;i&lt;=n;++i)if(vis[i])&#123; for(int j=1;j&lt;=n;++j)if(!vis[j]) val[i][j]=val[j][i]=min(val[i][j],ans); &#125; int ta=l,tb=r; for(int i=l;i&lt;=r;++i)&#123; if(vis[a[i]]) temp[ta++]=a[i]; else temp[tb--]=a[i]; &#125; for(int i=l;i&lt;=r;++i) a[i]=temp[i]; solve(l,ta-1); solve(tb+1,r); &#125;void pre()&#123; len=1; memset(Link,0,sizeof(Link)); memset(val,10,sizeof(val));&#125;void solve()&#123; n=read(); m=read(); pre(); for(int i=1;i&lt;=n;++i) a[i]=i; for(int i=1;i&lt;=m;++i)&#123; int x=read(),y=read(),v=read(); insert(x,y,v); insert(y,x,v); &#125; solve(1,n); for(int T=read();T;--T)&#123; int x=read(),ans=0; for(int i=1;i&lt;=n;++i)for(int j=i+1;j&lt;=n;++j) if(val[i][j]&lt;=x) ans++; printf("%d\n",ans); &#125; printf("\n");&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); for(int T=read();T;--T) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>最小割</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2160】拉拉队排练]]></title>
    <url>%2F2017%2F03%2F14%2F2160%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 这是随机程序摇出来的第二道水题。。。。。。 直接先上manacher，然后统计出cnt[i]数组表示长度为i的回文串的数量 这里注意在这道题中，偶数长度的串不算回文串（把我坑的好惨） 然后用k随便搞搞快速幂就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 2000010using namespace std;typedef long long ll;const int mod=19930726;int len[MAXN],cnt[MAXN];ll n,k,ans(1);char a[MAXN],b[MAXN];inline ll read()&#123; ll x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;ll fast(ll a,ll b)&#123;ll mul(1);for(;b;b&gt;&gt;=1,a=a*a%mod)if(b&amp;1)mul=mul*a%mod;return mul;&#125;void init()&#123; scanf("%s",a+1); b[0]='&amp;'; for(int i=1;i&lt;=n;++i) b[i*2-1]='#',b[i*2]=a[i]; b[n*2+1]='#'; b[n*2+2]='$'; n=n*2+1;&#125;void manacher()&#123; int pos=0,mx=0; for(int i=1;i&lt;=n;++i)&#123; len[i]=i&lt;mx?min(len[pos*2-i],mx-i):0; while(b[i-len[i]]==b[i+len[i]]) len[i]++; if(i+len[i]&gt;mx) mx=i+len[i],pos=i; &#125;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); k=read(); int flag=0; init(); manacher(); for(int i=1;i&lt;=n;++i) if(!(i&amp;1)) cnt[len[i]-1]++; for(int i=n;i&gt;2;--i) cnt[i-2]+=cnt[i]; for(int i=n;i;--i)if(cnt[i])&#123; if(k&gt;cnt[i]) k-=cnt[i],ans=ans*fast(i,cnt[i])%mod; else &#123;ans=ans*fast(i,k)%mod;flag=1;break;&#125; &#125; if(!flag) printf("-1"); else printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1517】Met]]></title>
    <url>%2F2017%2F03%2F14%2F1517%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 上午被子祯的题虐了一通，下午便去做一发水题。 想知道我是怎么选中这道题的？写一个随机数生成器就行了。。。。。。 这是一道结论题。 首先我们按照拓扑序将图分层，对于一个点，我们都可以从它的子树中选出一个点使得这个点被覆盖。 考虑每一层，我们最多可以选$2l$个点，由于每层的节点数必然是单调递增的，所以假设在第i层选了x个点，那么i-1层一定可以选$min(x,cnt[i-1])$个点 所以我们只需要拓扑排序统计每层的节点数即可 结论就是$ans=\sum min(cnt[i],l*2)$ (cnt[i]表示第i层节点数) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 1000010using namespace std;struct node&#123;int y,next;&#125;e[MAXN&lt;&lt;1];int n,m,len,ans,Link[MAXN],d[MAXN],q[MAXN],cnt[MAXN],level[MAXN];char buf[1&lt;&lt;15],*fs,*ft;inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125;inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f;&#125;void insert(int x,int y)&#123;e[++len].next=Link[x];Link[x]=len;e[len].y=y;d[y]++;&#125;void topsort()&#123; int head=0,tail=0; for(int i=1;i&lt;=n;++i) if(d[i]==1) q[++tail]=i; while(++head&lt;=tail)&#123; for(int i=Link[q[head]];i;i=e[i].next)&#123; if(--d[e[i].y]==1)&#123; q[++tail]=e[i].y; level[q[tail]]=level[q[head]]+1; &#125; &#125; &#125;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); m=read(); for(int i=1;i&lt;n;++i)&#123; int x=read(),y=read(); insert(x,y); insert(y,x); &#125; topsort(); for(int i=1;i&lt;=n;++i) cnt[level[i]]++; for(int i=0;cnt[i];++i) ans+=min(m*2,cnt[i]); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1044】木棍分割]]></title>
    <url>%2F2017%2F03%2F12%2F1044%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 第一问二分答案，随便验证 最大的最小，有一种二分的冲动 第二问，蒟蒻无耻的偷看了题解。。。 用$f[i][j]$表示前j根木棍分成i块的方案数 则$f[i][j]= \sum f[i-1][k]$ (sum[j]-sum[k]&gt;=mx) 滚动数组优化空间，单调性优化时间即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 50010#define mod 10007using namespace std;int n,m,mx,ans,sum[MAXN],a[MAXN],f[2][MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;bool check(int x)&#123; int temp=0,cnt=0; for(int i=1;i&lt;=n;++i)&#123; temp+=a[i]; if(temp&gt;x) temp=a[i],cnt++; if(temp&gt;x) return 0; &#125; return cnt&lt;=m;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); m=read(); int l=0,r=0; for(int i=1;i&lt;=n;++i) a[i]=read(),r+=a[i]; while(l+1&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid)) r=mid; else l=mid; &#125; mx=check(l)?l:r; f[0][0]=1; for(int i=2;i&lt;=n;++i) a[i]+=a[i-1]; for(int i=1;i&lt;=m+1;++i)&#123; int now=(i&amp;1),last=(now^1),k=0; sum[0]=f[last][0]; for(int j=1;j&lt;=n;++j) sum[j]=(sum[j-1]+f[last][j])%mod; f[now][0]=0; for(int j=i;j&lt;=n;++j)&#123; while(a[j]-a[k]&gt;mx) ++k; f[now][j]=(sum[j-1]-(k?sum[k-1]:0))%mod; &#125; ans=(ans+f[now][n])%mod; &#125; printf("%d %d\n",mx,(ans+mod)%mod); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>dp</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1042】硬币购物]]></title>
    <url>%2F2017%2F03%2F12%2F1042%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 看到只有四种面额的硬币，以及每种硬币数量的限制，很容易想到容斥 我们用f[i]表示总面额为i且不考虑数量限制的方案数 则f[i]可以预处理出来 容斥时只需要令不合法的硬币数量为d[i]+1，然后计算f[s-(d[i]+1)*c[i]]即可 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define FILE "read"typedef long long ll;using namespace std;const int MAXN=(int)1e5,D=50;int s,a[10],c[10],d[10];ll f[MAXN+D];inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;void pre()&#123; f[0]=1; for(int i=1;i&lt;=4;++i) for(int j=c[i];j&lt;=MAXN;++j) f[j]+=f[j-c[i]];&#125;void solve()&#123; ll ans=0; for(int i=1;i&lt;=4;++i) d[i]=read(); s=read(); for(int i=0;i&lt;(1&lt;&lt;4);++i)&#123; int cnt=0,temp=s; for(int j=1;j&lt;=4;++j)if((1&lt;&lt;(j-1))&amp;i)a[++cnt]=j; for(int j=1;j&lt;=cnt;++j) temp-=(d[a[j]]+1)*c[a[j]]; if(temp&lt;0) continue; ans+=(cnt&amp;1)?-f[temp]:f[temp]; &#125; printf("%lld\n",ans);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); for(int i=1;i&lt;=4;++i) c[i]=read(); pre(); for(int T=read();T;--T) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>容斥原理</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1778】驱逐猪猡]]></title>
    <url>%2F2017%2F03%2F12%2F1778%2F</url>
    <content type="text"><![CDATA[高斯消元重修系列第四题 这种题目算是一种讨论题，给了我们很多关于用高斯消元求解带环$dp$的启示 设向量$T(i)=${$x_1,x_2,……,x_n$}表示 $i$ 时刻在点 $x$ 爆炸的概率 我们构造转移矩阵 $E_{i,j}$ 表示从 $j$ 转移到 $i$ 的概率 则$E_{i,j}=\sum (1-\frac{P}{Q}) \times \frac{1}{d_j}$ 那么最终的答案向量$ans=\frac{P}{Q} \times T_0 (E^0+E^1+E^2+……)= \frac{P}{Q} \times T_0 \times \frac{I}{I-E}$ (I为单位矩阵) 如果你想用矩阵求逆的话直接做就行了，但是这里我们用高斯消元来做： 把分母移到左边得：$(I-E) \times ans = \frac{P}{Q} \times T_0 \times I$ 然后就符合高斯消元的套路了：(I-E)是系数矩阵，ans是答案向量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define FILE "read"#define eps 1e-10using namespace std;struct node&#123;int x,y;&#125;e[50010];double a[305][305];int n,m,p,q,d[305];inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;void init()&#123; n=read(); m=read(); p=read(); q=read(); double rate=(double)p/q; for(int i=1;i&lt;=m;++i)&#123; e[i].x=read(); e[i].y=read(); d[e[i].x]++; d[e[i].y]++; &#125; for(int i=1;i&lt;=m;++i)&#123; a[e[i].x][e[i].y]+=(rate-1)/d[e[i].y]; a[e[i].y][e[i].x]+=(rate-1)/d[e[i].x]; &#125; for(int i=1;i&lt;=n;++i) a[i][i]+=1.0; a[1][n+1]=rate;&#125;bool gauss()&#123; int now=1; for(int i=1,temp;i&lt;=n;++i)&#123; for(temp=now;temp&lt;=n;++temp) if(fabs(a[temp][i])&gt;eps) break; if(temp&gt;n) continue; if(temp!=now) swap(a[temp],a[now]); double t=a[now][i]; for(int j=i+1;j&lt;=n+1;++j) a[now][j]/=t; for(int j=1;j&lt;=n;++j)if(j!=now)&#123; double t=a[j][i]; for(int k=i+1;k&lt;=n+1;++k) a[j][k]-=t*a[now][k]; &#125; ++now; &#125; for(int i=now;i&lt;=n;++i) if(fabs(a[i][n+1])&gt;eps) return 0; return 1;&#125;void putout()&#123; for(int i=1;i&lt;=n;++i) printf("%.9lf\n",a[i][n+1]);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); init(); gauss(); putout(); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2419】电阻]]></title>
    <url>%2F2017%2F03%2F10%2F2419%2F</url>
    <content type="text"><![CDATA[高斯消元重修系列第二题 引用妹主席的一句话: 如今的OI界啊，仙人掌当道，玄学题横行，物理题为[和谐]一方 这种物理题我也是醉了 首先普及一下电流守恒定律：流入一个点的电流和等于流出这个点的电流和（和网络流有点像） 然后根据欧姆定律有：$I_{i,j}=\frac{E_i-E_j}{R_{i,j}}$ 带入电流守恒定律有：$\sum \frac{E_i-E_j}{R_{i,j}}=0$ (i与j有电阻相连) 特别的，对于1号点：$\sum \frac{E_i-E_j}{R_{i,j}}=1$ 对于n号点：$\sum \frac{E_i-E_j}{R_{i,j}}=-1$ 根据这些列出n个方程，高斯消元即可 注意重边要累加电阻，自环要忽略，上邻接矩阵存图即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define FILE "read"#define eps 1e-6using namespace std;double a[510][510],Map[510][510];int n,m;inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;void init()&#123; memset(Map,0,sizeof(Map)); memset(a,0,sizeof(a)); for(int i=1;i&lt;=m;++i)&#123; int x=read(),y=read(),r=read(); Map[x][y]+=1.0/r; Map[y][x]+=1.0/r; &#125; for(int i=1;i&lt;=n;++i)for(int j=1;j&lt;=n;++j)&#123; a[i][i]+=Map[i][j]; a[i][j]-=Map[i][j]; &#125; a[1][n+1]=1; a[n][n+1]=-1;&#125;bool gauss()&#123; int now=1; for(int i=1,temp;i&lt;=n;++i)&#123; for(temp=now;temp&lt;=n;++temp) if(fabs(a[temp][i])&gt;eps) break; if(temp&gt;n) continue; if(temp!=now) for(int j=1;j&lt;=n+1;++j) swap(a[now][j],a[temp][j]); double t=a[now][i]; for(int j=1;j&lt;=n+1;++j) a[now][j]/=t; for(int j=1;j&lt;=n;++j)if(j!=now)&#123; double t=a[j][i]; for(int k=1;k&lt;=n+1;++k) a[j][k]-=t*a[now][k]; &#125; ++now; &#125; for(int i=now;i&lt;=n;++i)if(fabs(a[i][n+1])&gt;eps)return 0; return 1;&#125;void output()&#123; printf("%.2lf\n",a[1][n+1]);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; init();gauss();output(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1013】球形空间产生器]]></title>
    <url>%2F2017%2F03%2F10%2F1013%2F</url>
    <content type="text"><![CDATA[高斯消元重修系列第一题 AC通道 这题之前做过，但是今天妹主席讲了一发矩阵相关，我突然发现。。。我好像忘了高斯消元怎么写了 这道题思路很妙： 设圆心为$(r_1,r_2,……,r_n)$,然后任选两个点$(x_1,x_2,……,x_n),(y_1,y_2,……,y_n)$，则有： $(r_1-x_1)^2+(r_2-x_2)^2+……+(r_n-x_n)^2=(r_1-y_1)^2+(r_2-y_2)^2+……+(r_n-y_n)^2$ 展开后可将$r$的二次项消掉：$2(y_1-x_1)r_1+2(y_2-x_2)r_2+……+2(y_n-x_n)r_n=(y_1^2-x_1^2)+(y_2^2-x_2^2)+……+(y_n^2-x_n^2)$ 使用高斯消元即可解出圆心坐标 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define FILE "read"#define eps 1e-6using namespace std;double f[15],a[15][15];int n;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%lf",&amp;f[i]); for(int i=1;i&lt;=n;++i)for(int j=1;j&lt;=n;++j)&#123; double x;scanf("%lf",&amp;x); a[i][j]=2*(x-f[j]); a[i][n+1]+=x*x-f[j]*f[j]; &#125;&#125;bool gauss()&#123; int now=1; for(int i=1,temp;i&lt;=n;++i)&#123; for(temp=now;temp&lt;=n;++temp) if(fabs(a[temp][i])&gt;eps) break; if(temp&gt;n) continue; if(temp!=now) for(int j=1;j&lt;=n+1;++j) swap(a[temp][j],a[now][j]); double t=a[now][i]; for(int j=1;j&lt;=n+1;++j) a[now][j]/=t; for(int j=1;j&lt;=n;++j)if(j!=now)&#123; double t=a[j][i]; for(int k=1;k&lt;=n+1;++k)a[j][k]-=t*a[now][k]; &#125; ++now; &#125; for(int i=now;i&lt;=n;++i)if(fabs(a[i][n+1])&gt;eps) return 0; return 1;&#125;void output()&#123; for(int i=1;i&lt;=n-1;++i) printf("%.3lf ",a[i][n+1]); printf("%.3lf",a[n][n+1]);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); init(); gauss(); output(); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2434】阿狸的打字机]]></title>
    <url>%2F2017%2F03%2F07%2F2434%2F</url>
    <content type="text"><![CDATA[AC自动机重修系列第一题 AC通道 今天吕老板讲了一发字符串，然后。。。我发现我好像学了假的AC自动机？ 于是今晚恶补一发，此题便是AC自动机重修系列第一题 原先写这题的时候还是没有搞懂fail树这种神奇的东西，于是我去百度了一下，有一篇博文写得很好传送门 查询x在y中的出现次数，我们可以离线搞 对于每个询问，从y向x连边，那么我们在跑AC自动机时，每得到一个串就可以计算该串对应的x的答案 关于删除操作，只需要在建AC自动机时返回父节点即可，注意下面代码中的fail和f不可混淆 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 200010using namespace std;struct node&#123;int y,next;&#125;e[MAXN],qe[MAXN];int n,m,cnt,len,dfs_clock,ans[MAXN],pos[MAXN],fail[MAXN],f[MAXN],q[MAXN],Link[MAXN],qLink[MAXN],L[MAXN],R[MAXN],c[MAXN],tr[MAXN][26];char ch[MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;void insert(int x,int y)&#123;e[++len].next=Link[x];Link[x]=len;e[len].y=y;&#125;void add(int x,int v)&#123;while(x&lt;=dfs_clock)c[x]+=v,x+=(x&amp;-x);&#125;int get(int x)&#123;int temp(0);while(x)temp+=c[x],x-=(x&amp;-x);return temp;&#125;void extend()&#123; int now=0,id=0; for(int i=1;i&lt;=n;++i)&#123; if(ch[i]=='P') pos[++id]=now; else if(ch[i]=='B') now=f[now]; else&#123; if(!tr[now][ch[i]-'a']) tr[now][ch[i]-'a']=++cnt,f[cnt]=now; now=tr[now][ch[i]-'a']; &#125; &#125;&#125;void build()&#123; int head=0,tail=0; for(int i=0;i&lt;26;++i) if(tr[0][i]) q[++tail]=tr[0][i]; while(++head&lt;=tail)&#123; int x=q[head]; for(int i=0;i&lt;26;++i)&#123; if(!tr[x][i]) tr[x][i]=tr[fail[x]][i]; else fail[tr[x][i]]=tr[fail[x]][i],q[++tail]=tr[x][i]; &#125; &#125; for(int i=1;i&lt;=cnt;++i) insert(fail[i],i);&#125;void init()&#123; scanf("%s",ch+1); n=strlen(ch+1); extend(); build(); m=read(); for(int i=1;i&lt;=m;++i)&#123; int x=read(),y=read(); qe[i].next=qLink[y];qLink[y]=i;qe[i].y=x; &#125;&#125;void dfs(int x)&#123; L[x]=++dfs_clock; for(int i=Link[x];i;i=e[i].next) dfs(e[i].y); R[x]=++dfs_clock;&#125;void solve()&#123; dfs(0); int now=0,id=0; for(int i=1;i&lt;=n;++i)&#123; if(ch[i]=='P')&#123; for(int j=qLink[++id];j;j=qe[j].next)&#123; int x=pos[qe[j].y]; ans[j]=get(R[x])-get(L[x]-1); &#125; &#125; else if(ch[i]=='B') add(L[now],-1),now=f[now]; else now=tr[now][ch[i]-'a'],add(L[now],1); &#125; for(int i=1;i&lt;=m;++i) printf("%d\n",ans[i]);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); init(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>AC自动机</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1823】满汉全席]]></title>
    <url>%2F2017%2F03%2F06%2F1823%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 不管是这一段的CF，还是今天的测试，cydiater大神都多次提到2-sat问题，为此我在今晚恶补一发 所谓2-sat，其实是一种图论模型，用于解决集合元素的双决策问题 比如这题就是一个板子 2-sat巧妙地将元素的决策问题转化为了图论模型，并以O(m)的优越复杂度解决问题，确实很妙 这里记录一下做题时犯得sb错误： （1）读入函数写错(zz真是没救了)（2）int类型的get()函数没有return（3）数组开小 犯这种错误我也是醉了，还好我静态差错能力较强，否则一晚上就进去了 留一个代码作为2-sat的板子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define FILE "read"#define MAXN 20100#define cmin(a,b) a=min(a,b)#define cmax(a,b) a=max(a,b)using namespace std;struct node&#123;int y,next;&#125;e[MAXN&lt;&lt;1];int n,m,top,len,bcnt,dfs_clock,Link[MAXN],vis[MAXN],st[MAXN],dfn[MAXN],low[MAXN],belong[MAXN];inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f;&#125;void insert(int x,int y)&#123;e[++len].next=Link[x];Link[x]=len;e[len].y=y;&#125;int get()&#123; int x; char ch=getchar(); while(ch!='m'&amp;&amp;ch!='h') ch=getchar(); if(ch=='m') x=read()*2; else x=read()*2-1; return x;&#125;void tarjan(int x)&#123; dfn[x]=low[x]=++dfs_clock; st[++top]=x; vis[x]=1; for(int i=Link[x];i;i=e[i].next)&#123; if(!dfn[e[i].y])&#123; tarjan(e[i].y); cmin(low[x],low[e[i].y]); &#125; else if(vis[e[i].y]) cmin(low[x],dfn[e[i].y]); &#125; if(dfn[x]==low[x])&#123; bcnt++; int y; do&#123; y=st[top--]; belong[y]=bcnt; vis[y]=0; &#125;while(x!=y); &#125;&#125;void pre()&#123; top=bcnt=len=dfs_clock=0; memset(Link,0,sizeof(Link)); memset(dfn,0,sizeof(dfn));&#125;void solve()&#123; top=dfs_clock=len=bcnt=0; n=read(); m=read(); for(int i=1;i&lt;=2*n;i++) Link[i]=dfn[i]=0; for(int i=1;i&lt;=m;++i)&#123; int x=get(),y=get(),xp,yp; int px=(x&amp;1?x+1:x-1),py=(y&amp;1?y+1:y-1); insert(x,py); insert(y,px); &#125; for(int i=1;i&lt;=n*2;++i) if(!dfn[i]) tarjan(i); for(int i=1;i&lt;=n*2;i+=2) if(belong[i]==belong[i+1]) &#123;puts("BAD"); return;&#125; puts("GOOD");&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); for(int T=read();T;--T) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1930】吃豆豆]]></title>
    <url>%2F2017%2F03%2F02%2F1930%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 吐槽先讲一个悲伤的故事 这是我从学OI至今提交次数最多的一道题，题目很水，但是很坑 首先这题卡空间，然后编译超时（excuse me？） 然后卡空间时各种RE 然后去膜大牛的代码，发现需要优化边数，然后又是各种wa 最后发现图建错了。。。。。 于是我的一下午就被这道水题坑走了 题解问题可以转化为，吃豆人路径可以相交。因为如果路径相交，可以从相交位置开始交换两个吃豆人的后续路径。 考虑到所有豆之间组成了一张有向无环图，我们尝试网络流建模。 对于每个点，有经过次数限制和经过它的收益。 拆点费用流即可。 具体建模： 每个豆豆对应2个点ai,bi，另有S,SS,T,TT SS-&gt;S流量2费用0 ai-&gt;bi要建两条边：一条流量为1费用1，一条流量为1费用为0； S-&gt;ai流量INF费用0；bi-&gt;TT流量INF费用0。 TT-&gt;T流量2费用0 跑最大费用最大流即可。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define FILE "read"#define INF 1000000000using namespace std;const int MAXN=(int)5010;struct node&#123;int y,next,v,w,rel;&#125;e[200000];int n,len,S,T,TT,ans,Link[MAXN],vis[MAXN],dis[MAXN],q[MAXN],lastnode[MAXN],lastedge[MAXN],flow[MAXN];pair&lt;int,int&gt; a[MAXN];namespace INIT&#123; char buf[1&lt;&lt;15],*fs,*ft; inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125; inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f; &#125;&#125;using namespace INIT;void insert(int x,int y,int v,int w)&#123; e[++len].next=Link[x];Link[x]=len;e[len].y=y;e[len].v=v;e[len].w=-w;e[len].rel=len+1; e[++len].next=Link[y];Link[y]=len;e[len].y=x;e[len].v=0;e[len].w=w;e[len].rel=len-1;&#125;bool spfa()&#123; memset(vis,0,sizeof(vis)); memset(dis,10,sizeof(dis)); int head=0,tail=1,oo=dis[0]; q[1]=S; dis[S]=0; vis[S]=1; flow[S]=INF; while(head!=tail)&#123; int x=q[++head]; vis[x]=0; if(head==5000) head=0; for(int i=Link[x];i;i=e[i].next)&#123; if(e[i].v&amp;&amp;e[i].w+dis[x]&lt;dis[e[i].y])&#123; dis[e[i].y]=e[i].w+dis[x]; flow[e[i].y]=min(e[i].v,flow[x]); if(!vis[e[i].y])&#123; vis[e[i].y]=1; q[++tail]=e[i].y; if(tail==5000) tail=0; &#125; lastnode[e[i].y]=x; lastedge[e[i].y]=i; &#125; &#125; &#125; if(dis[T]==oo) return 0; ans+=flow[T]*(-dis[T]); for(int i=T;i!=S;i=lastnode[i])&#123; e[lastedge[i]].v-=flow[T]; e[e[lastedge[i]].rel].v+=flow[T]; &#125; return 1;&#125;void solve()&#123; while(spfa()); printf("%d\n",ans);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); S=n*2+1; TT=S+1; T=TT+1; for(int i=1;i&lt;=n;++i)&#123; a[i].first=read(); a[i].second=read(); insert(0,i,2,0); insert(i,i+n,1,1); insert(i,i+n,1,0); insert(i+n,TT,2,0); &#125; sort(a+1,a+n+1); for(int i=1;i&lt;=n;++i)&#123; int maxx=INF; for(int j=i+1;j&lt;=n;++j) if(a[j].second&gt;=a[i].second&amp;&amp;a[j].second&lt;maxx)&#123; insert(i+n,j,2,0); maxx=a[j].second; &#125; &#125; insert(S,0,2,0); insert(TT,T,2,0); solve(); return 0;&#125; 附makedata程序1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#define FILE "read"using namespace std;map&lt;pair&lt;int,int&gt;,int&gt;M;int main()&#123; freopen(FILE".in","w",stdout); srand(time(NULL)); int n=2000; printf("%d\n",n); /*for(int i=1;i&lt;=n/2;++i)&#123; printf("%d %d\n",i,i); &#125;*///构造数据 for(int i=1;i&lt;=n;++i)&#123; int x=rand()%1000+1,y=rand()%1000+1; while(M[make_pair(x,y)]) x=rand()%1000+1,y=rand()%1000+1; M[make_pair(x,y)]=1; printf("%d %d\n",x,y); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1457】棋盘游戏]]></title>
    <url>%2F2017%2F03%2F02%2F1457%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 题解这个问题与我们之前遇到的并不类似。我们擅长的问题通常是“不能操作者判负”的问题。因此，我们尝试转化。 注意到，如果初始情况下，有皇后可以通过一步操作直接到达，那么先手只要这么操作，就能直接获胜，因此这种局面是先手必胜的。 否则，玩家除非走投无路，否则一定不能把皇后移动到这些“通过一步操作可以直接到达”的位置（下面简称“禁区”）。也就是说，如果认为这些禁区是不能停留的，那么原问题就转化为了不能操作者判负的问题。 经过这样的转化，模型就不难建出了，这是一个有向无环图，直接按定义计算出每个位置的SG函数值并计算答案即可。 ——题解来自王队长《OI中的博弈论》 参考代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define FILE "read"using namespace std;const int MAXN=(int)1e3,D=50;int a[MAXN+D],b[MAXN+D],check[MAXN+D],sg[105][105];namespace INIT&#123; char buf[1&lt;&lt;15],*fs,*ft; inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125; inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f; &#125;&#125;using namespace INIT;void pre()&#123; for(int i=0;i&lt;=99;++i) for(int j=0;j&lt;=99;++j)&#123; if(i==j||i*j==0) continue; memset(check,0,sizeof(check)); for(int k=1;k&lt;min(i,j);++k)check[sg[i-k][j-k]]=1; for(int k=1;k&lt;i;++k)if(i-k!=j)check[sg[i-k][j]]=1; for(int k=1;k&lt;j;++k)if(i!=j-k)check[sg[i][j-k]]=1; for(int k=0;k&lt;=MAXN;++k)if(!check[k])&#123;sg[i][j]=k;break;&#125; &#125;&#125;void solve()&#123; int n=read(),ans(0); for(int i=1;i&lt;=n;++i) a[i]=read(),b[i]=read(); for(int i=1;i&lt;=n;++i) ans^=sg[a[i]][b[i]]; puts(ans?"^o^":"T_T");&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); pre(); for(int T=read();T;--T) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1188】分裂游戏]]></title>
    <url>%2F2017%2F03%2F02%2F1188%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 题解可以发现，每个石子互相独立，且位置相同的石子等价。所以我们可以预处理出每个位置的$SG$函数值。 如果令状态$u$表示有一枚石子在第$u$堆的状态，那么它的后继状态就是所有“有一枚石子在$j$，一枚石子在$k$，且$j,k$在$u$的右边”的状态。 也就是说，$SG(u)=mex${$SG(j) xor SG(k)|j,k&gt;u$} 最后，我们求出所有石子的$SG$函数值（每个石子的SG函数值为其初始位置的$SG$函数值）的异或和，判断其是否为$0$，即可求得答案。 对于第一步操作，我们可以按字典序枚举之，再计算进行操作后的先后手必胜情况，来判断这一操作是否合法。 ——题解来自王队长《OI中的博弈论》 参考代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define FILE "read"using namespace std;const int MAXN=(int)1e4,D=50;int ans[5],a[25],check[MAXN+D],sg[MAXN+D];namespace INIT&#123; char buf[1&lt;&lt;15],*fs,*ft; inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125; inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f; &#125;&#125;using namespace INIT;void solve()&#123; int n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); memset(check,0,sizeof(check)); memset(sg,0,sizeof(sg)); memset(ans,0,sizeof(ans)); for(int i=n-1;i;--i)&#123; for(int j=i+1;j&lt;=n;++j)for(int k=j;k&lt;=n;++k)check[sg[j]^sg[k]]=i; for(int j=0;j&lt;=MAXN;++j)if(check[j]!=i)&#123;sg[i]=j;break;&#125; &#125; for(int i=1;i&lt;=n;++i)if(a[i]&amp;1)ans[0]^=sg[i]; for(int i=n-1;i;--i)for(int j=n;j&gt;=i+1;--j)for(int k=n;k&gt;=j;--k) if((ans[0]^sg[i]^sg[j]^sg[k])==0) ans[1]=i,ans[2]=j,ans[3]=k,ans[4]++; printf("%d %d %d\n%d\n",ans[1]-1,ans[2]-1,ans[3]-1,ans[4]);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); for(int T=read();T;--T) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1874】取石子游戏]]></title>
    <url>%2F2017%2F03%2F02%2F1874%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 题解首先我们求出所有状态的$SG$函数，很显然这道题中$x$的后继状态为$succ(x)=${$ x-v |v\in B $} 那么所有$SG(A[i])$的抑或和不为$0$是先手必胜的条件 至于输出方案，暴力枚举即可 这道题目告诉我一定要注意位运算的优先级，博主因为这个wa掉多次 参考代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define FILE "read"using namespace std;const int MAXN=(int)1e3,D=50;int n,m,ans,a[15],b[15],check[MAXN+D],sg[MAXN+D];namespace INIT&#123; char buf[1&lt;&lt;15],*fs,*ft; inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125; inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f; &#125;&#125;using namespace INIT;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); for(int i=1;i&lt;=n;++i) a[i]=read(); m=read(); for(int i=1;i&lt;=m;++i) b[i]=read(); for(int i=1;i&lt;=MAXN;++i)&#123; for(int j=1;j&lt;=m;++j) if(i-b[j]&gt;=0) check[sg[i-b[j]]]=i; for(int j=0;j&lt;=MAXN;++j) if(check[j]!=i) &#123;sg[i]=j; break;&#125; &#125; for(int i=1;i&lt;=n;++i) ans^=sg[a[i]]; if(ans)&#123; puts("YES"); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; if((ans^sg[a[i]]^sg[a[i]-b[j]])==0)&#123; printf("%d %d\n",i,b[j]); exit(0); &#125; &#125; &#125; else puts("NO"); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1115】石子游戏Kam]]></title>
    <url>%2F2017%2F03%2F02%2F1115%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 题解每堆石子的个数不少于前一堆石子的个数可以看成是相邻两堆石子时间的个数差保持非负。 于是可以把这些石子差看做石子，每次操作会将其中一堆石子减去一个值，又会将它后面的一堆加上相等的值，就可以看做是把这一堆推到它后面的一堆。 于是转化成了阶梯博弈。 手瞎眼瞎的博主犯了很低级的错误：把输出中的”NIE”打成了”NIM”，然后就是无限wa 参考代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define FILE "read"using namespace std;int n,a[1010];namespace INIT&#123; char buf[1&lt;&lt;15],*fs,*ft; inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125; inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f; &#125;&#125;using namespace INIT;void solve()&#123; n=read(); int ans=0; for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=n;i&gt;=1;i-=2) ans^=(a[i]-a[i-1]); puts(ans?"TAK":"NIE");&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); for(int T=read();T;--T) solve(); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2154】Crash的数字表格]]></title>
    <url>%2F2017%2F03%2F01%2F2154%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 题目大意一句话题意：给定n,m,求$\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)(n,m&lt;=10^7)$ -- 题解$ans=\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i\times j}{gcd(i,j)}$ 令$d=gcd(i,j)$，$F(x,y)=\sum_{1&lt;=i&lt;=x,1&lt;=j&lt;=y,gcd(i,j)=1}^{ }i \times j$ 然后我们枚举$d$，则有$ans=\sum_{d=1}^{min(n,m)}\frac{d^2 \times F(\left [ \frac{n}{d} \right ],\left [ \frac{m}{d} \right ])}{d}=\sum_{d=1}^{min(n,m)}d\times F(\left [ \frac{n}{d} \right ],\left [ \frac{m}{d} \right ])$ 令$Sum(x,y)=\sum_{i=1}^{x}\sum_{j=1}^{y}i \times j=\frac{x(x-1)}{2}\times\frac{y(y-1)}{2}$ 显然$Sum(x,y)=\sum_{i=1}^{min(x,y)}i^2 \times F(\left [ \frac{x}{i} \right ],\left [ \frac{y}{i} \right ])$ 通过莫比乌斯反演可得$F(x,y)=\sum_{i=1}^{min(x,y)}i^2\times \mu(i)\times Sum(\left [ \frac{x}{i} \right ],\left [ \frac{y}{i} \right ])$ 这两个式子都可以进行$O(\sqrt n)$的计算，所以总的时间复杂度是$O(n)$ 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;#define FILE "read"#define cmax(a,b) a=max(a,b)#define cmin(a,b) a=min(a,b)const int MAXN=(int)1e7,D(50),mod=20101009;int n,m,cnt,prime[MAXN+D],check[MAXN+D],mu[MAXN+D];ll ans,sum[MAXN+D];namespace INIT&#123; char buf[1&lt;&lt;15],*fs,*ft; inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125; inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f; &#125;&#125;using namespace INIT;void pre()&#123; mu[1]=1; for(ll i=2;i&lt;=min(n,m);++i)&#123; if(!check[i]) prime[++cnt]=i,mu[i]=-1; for(ll j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=min(n,m);++j)&#123; check[prime[j]*i]=1; if(i%prime[j]==0) &#123;mu[i*prime[j]]=0; break;&#125; mu[i*prime[j]]=-mu[i]; &#125; &#125; for(ll i=1;i&lt;=min(n,m);++i) sum[i]=((sum[i-1]+(mu[i]*i*i%mod)+mod)%mod+mod)%mod;&#125;ll cal(ll x,ll y)&#123;return ((x*(x+1)/2%mod)*(y*(y+1)/2%mod))%mod;&#125;ll get(ll x,ll y)&#123; if(x&gt;y) swap(x,y); ll temp(0); for(ll i=1,last;i&lt;=x;i=last+1)&#123; last=min(x/(x/i),y/(y/i)); temp+=((sum[last]-sum[i-1])*cal(x/i,y/i))%mod; temp%=mod; &#125; return temp;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); m=read(); pre(); if(n&gt;m) swap(n,m); for(ll i=1,last;i&lt;=n;i=last+1)&#123; last=min(n/(n/i),m/(m/i)); ans+=(i+last)*(last-i+1)/2%mod*get(n/i,m/i)%mod; ans%=mod; &#125; printf("%lld\n",(ans+mod)%mod); return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0228考试总结]]></title>
    <url>%2F2017%2F02%2F28%2F0228%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[辣鸡果然倒数 AC通道 本次测试略显失败，辣鸡25分滚粗，而三位大佬都是100+ T1宏大的区间来自$bzoj3226$，数据加强了一下 传送门 这题是一道比较裸的线段树题目，维护方法也很简单 但是考试中没有想到使用线段树维护区间，我想到了一个与线段树复杂度同阶的二分+枚举算法，在写了100多行的if大讨论后认为这题不可做，放弃了。 首先我们把开区间离散一下，比如$(2,5)$我们可以认为是$[2.5,4.5]$ 然后把所有坐标乘2，然后认为奇数坐标为开，偶数坐标为闭 然后上线段树即可，注意标记的下传 写好程序后蒟蒻发现读入写挂了。。。果然是我弱啊 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define FILE "interval"#define cmax(a,b) a=max(a,b)#define cmin(a,b) a=min(a,b)using namespace std;const int MAXN=524287,D=50;int tr[MAXN&lt;&lt;2];char opt[5];void pushdown(int p)&#123; if(tr[p]==1||tr[p]==-1)&#123; tr[p*2]=tr[p*2+1]=tr[p]; &#125;else if(tr[p]==2)&#123; tr[p*2]=-tr[p*2]; tr[p*2+1]=-tr[p*2+1]; &#125; tr[p]=-2;&#125;void insert(int p,int l,int r,int x,int y,int v)&#123; if(x&gt;r||y&lt;l) return; if(x&lt;=l&amp;&amp;y&gt;=r) &#123;tr[p]=v; return;&#125; pushdown(p); int mid=(l+r)&gt;&gt;1; insert(p&lt;&lt;1,l,mid,x,y,v); insert(p&lt;&lt;1|1,mid+1,r,x,y,v);&#125;void updata(int p,int l,int r,int x,int y)&#123; if(x&gt;r||y&lt;l) return; if(x&lt;=l&amp;&amp;y&gt;=r) &#123;tr[p]=-tr[p]; return;&#125; pushdown(p); int mid=(l+r)&gt;&gt;1; updata(p&lt;&lt;1,l,mid,x,y); updata(p&lt;&lt;1|1,mid+1,r,x,y);&#125;void clear(int p,int l,int r)&#123; if(l&gt;=r) return; pushdown(p); int mid=(l+r)&gt;&gt;1; clear(p&lt;&lt;1,l,mid); clear(p&lt;&lt;1|1,mid+1,r);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); memset(tr,-1,sizeof(tr)); while(scanf("%s",opt+1)!=EOF)&#123; char ch=getchar(); while(ch!='('&amp;&amp;ch!='[') ch=getchar(); int flag=(ch=='('),a,b; scanf("%d,%d",&amp;a,&amp;b); a=a*2+flag; ch=getchar(); while(ch!=')'&amp;&amp;ch!=']') ch=getchar(); flag=(ch==')'); b=b*2-flag; if(opt[1]=='U') insert(1,0,MAXN,a,b,1); else if(opt[1]=='I')&#123; if(a) insert(1,0,MAXN,0,a-1,-1); insert(1,0,MAXN,b+1,MAXN,-1); &#125; else if(opt[1]=='D') insert(1,0,MAXN,a,b,-1); else if(opt[1]=='C')&#123; if(a) insert(1,0,MAXN,0,a-1,-1); insert(1,0,MAXN,b+1,MAXN,-1); updata(1,0,MAXN,a,b); &#125; else updata(1,0,MAXN,a,b); &#125; clear(1,0,MAXN); tr[MAXN]=-1; int flag=1; for(int i=0;i&lt;=MAXN;++i)&#123; if(tr[i+MAXN+1]==1&amp;&amp;tr[i+MAXN]==-1)&#123; if(flag)&#123; printf(i&amp;1?"(":"[");printf("%d,",i&gt;&gt;1); flag=0; continue; &#125; printf(" ");printf(i&amp;1?"(":"[");printf("%d,",i&gt;&gt;1); &#125; if(tr[i+MAXN+1]==-1&amp;&amp;tr[i+MAXN]==1)&#123; printf("%d",i&gt;&gt;1);printf(i&amp;1?"]":")"); &#125; &#125; if(flag) puts("empty set"); return 0;&#125; --- T2滑稽题目大意：有4个数组A,B,C,D，一个四元组是滑稽的当且仅当每个元素来自不同的数组，且他们的乘积模P为1，其中P为质数。求有多少个滑稽的四元组。 说起这题我就心痛啊，由于没有开$long long$，我的正解只拿到了$25$分 这题做法很简单，将$A[i]\times {B[j]}$的值存入一个桶中，然后枚举$C[i]\times {D[j]}$，求其逆元，然后统计答案就行了 虽然评测时开$O2$，但是本地测试使用$map$约为$1.4s$，所以我将$map$改成了二分，成功卡进$0.6s$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#define FILE "huaji"using namespace std;typedef long long ll;namespace INIT&#123; char buf[1&lt;&lt;15],*fs,*ft; inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125; inline ll read()&#123; ll x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f; &#125;&#125;using namespace INIT;ll n,mod,cnt,ans,a[1010],b[1010],c[1010],d[1010],A[1001000],B[1001000];void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b) &#123;x=1; y=0; return;&#125; exgcd(b,a%b,x,y); ll t=x;x=y;y=t-a/b*y;&#125;ll findl(ll v)&#123; ll l=1,r=cnt,temp(0); while(l&lt;=r)&#123; ll mid=(l+r)&gt;&gt;1; if(B[mid]&lt;v) l=mid+1; else temp=mid,r=mid-1; &#125; return temp;&#125;ll findr(ll v)&#123; ll l=1,r=cnt,temp(0); while(l&lt;=r)&#123; ll mid=(l+r)&gt;&gt;1; if(B[mid]&lt;=v) &#123;temp=mid; l=mid+1;&#125; else r=mid-1; &#125; return temp;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); mod=read(); for(ll i=1;i&lt;=n;++i) a[i]=read()%mod; for(ll i=1;i&lt;=n;++i) b[i]=read()%mod; for(ll i=1;i&lt;=n;++i) c[i]=read()%mod; for(ll i=1;i&lt;=n;++i) d[i]=read()%mod; for(ll i=1;i&lt;=n;++i) for(ll j=1;j&lt;=n;++j) A[++cnt]=a[i]*b[j]%mod; cnt=0; for(ll i=1;i&lt;=n;++i) for(ll j=1;j&lt;=n;++j) B[++cnt]=c[i]*d[j]%mod; sort(B+1,B+cnt+1); for(ll i=1;i&lt;=n*n;++i)&#123; if(A[i]==0) continue; ll x,y; exgcd(A[i],mod,x,y); x=(x%mod+mod)%mod; ll l=findl(x),r=findr(x); if(!l||!r) continue; ans+=r-l+1; &#125; printf("%lld\n",ans); return 0;&#125; T3吨吨反应炉来自$bzoj4593$ 传送门 这题数据略水，随便写一发就拿到了$bzoj$的$rank1$（主要还是写的人少） 正解：树形dp 我们用$f[i]$表示i节点不引爆父亲的情况下的最少花费，$h[i]$表示i节点在引爆父亲的情况下的最少花费 那么显然$h[i]&lt;=f[i]$恒成立 对于节点$x$以及它的儿子节点$y$，如果$f[y]-h[y]&gt;=c[y]$，那么我们用$h[y]$来转移，否则我们用$f[y]$来转移 就这样瞎搞搞就行了 当然正解不是这样子的，但是由于数据水，所以这样做就能水过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define FILE "fusion"#define MAXN 100010using namespace std;namespace INIT&#123; char buf[1&lt;&lt;15],*fs,*ft; inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125; inline int read()&#123; int x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f; &#125;&#125;using namespace INIT;struct node&#123;int y,next;&#125;e[MAXN*2];int n,len,ans,Link[MAXN],d[MAXN],c[MAXN],vis[MAXN],f[MAXN],h[MAXN],boom[MAXN],fa[MAXN];void insert(int x,int y)&#123;e[++len].next=Link[x];Link[x]=len;e[len].y=y;&#125;void dp(int x)&#123; int temp=0,sum=d[x]; vis[x]=1; for(int i=Link[x];i;i=e[i].next) if(!vis[e[i].y]&amp;&amp;c[e[i].y])&#123; fa[e[i].y]=x; dp(e[i].y); if(f[e[i].y]-h[e[i].y]&gt;=c[e[i].y]) temp+=h[e[i].y]; else temp+=f[e[i].y],sum-=c[e[i].y]; &#125; f[x]=temp+sum; h[x]=temp+sum-c[fa[x]];&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); n=read(); for(int i=1;i&lt;=n;++i) d[i]=read(); for(int i=1;i&lt;=n;++i) c[i]=read(); for(int i=1;i&lt;n;++i)&#123; int x=read(),y=read(); insert(x,y); insert(y,x); boom[x]+=c[y]; boom[y]+=c[x]; &#125; for(int i=1;i&lt;=n;++i) if(!c[i]) ans+=max(d[i]-boom[i],0); for(int i=1;i&lt;=n;++i) if(c[i]&amp;&amp;!vis[i]) fa[i]=0,c[0]=0,dp(i),ans+=f[i]; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>考试总结</tag>
        <tag>线段树</tag>
        <tag>乘法逆元</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj2034】K大数查询]]></title>
    <url>%2F2017%2F02%2F25%2F2034%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 题解我们可以用整体二分解决插入对询问的影响在此过程中，用线段树维护区间修改和区间查询即可 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;#define FILE "read"#define MAXN 50010#define INF 1000000000//#define up(i,j,n) for(int i=j;i&lt;=n;++i)//#define dn(i,j,n) for(int i=j;i&gt;=n;--i)#define cmax(a,b) a=max(a,b)#define cmin(a,b) a=min(a,b)struct node&#123;ll x,y,opt,k,id;&#125;q[MAXN],stack[MAXN][2];ll n,m,cnt,ans[MAXN];namespace INIT&#123; char buf[1&lt;&lt;15],*fs,*ft; inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125; inline ll read()&#123; ll x=0,f=1; char ch=getc(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getc();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getc();&#125; return x*f; &#125;&#125;using namespace INIT;namespace Segment_Tree&#123; ll tr[MAXN&lt;&lt;2],clean[MAXN&lt;&lt;2],delt[MAXN&lt;&lt;2]; void relord(int p)&#123;tr[p]=tr[p&lt;&lt;1]+tr[p&lt;&lt;1|1];&#125; void pushdown(int p,int l,int r)&#123; if(clean[p])&#123; clean[p&lt;&lt;1]=clean[p&lt;&lt;1|1]=1; clean[p]=0; delt[p&lt;&lt;1]=delt[p&lt;&lt;1|1]=tr[p&lt;&lt;1]=tr[p&lt;&lt;1|1]=0; &#125; ll d=delt[p],mid=(l+r)&gt;&gt;1; delt[p&lt;&lt;1]+=d; delt[p&lt;&lt;1|1]+=d; tr[p&lt;&lt;1]+=d*(mid-l+1); tr[p&lt;&lt;1|1]+=d*(r-mid); delt[p]=0; &#125; void insert(int p,int l,int r,int x,int y)&#123; if(x&gt;r||y&lt;l) return; if(x&lt;=l&amp;&amp;y&gt;=r) &#123;delt[p]++; tr[p]+=(r-l+1); return;&#125; int mid=(l+r)&gt;&gt;1; pushdown(p,l,r); insert(p&lt;&lt;1,l,mid,x,y); insert(p&lt;&lt;1|1,mid+1,r,x,y); relord(p); &#125; ll ask(int p,int l,int r,int x,int y)&#123; if(x&gt;r||y&lt;l) return 0; if(x&lt;=l&amp;&amp;y&gt;=r) return tr[p]; int mid=(l+r)&gt;&gt;1; pushdown(p,l,r); return ask(p&lt;&lt;1,l,mid,x,y)+ask(p&lt;&lt;1|1,mid+1,r,x,y); &#125;&#125;using namespace Segment_Tree;void init()&#123; n=read(); m=read(); up(i,1,m)&#123; ll opt=read(),x=read(),y=read(),k=read(); if(opt==1) q[i]=(node)&#123;x,y,opt,k,0&#125;; else q[i]=(node)&#123;x,y,opt,k,++cnt&#125;; &#125;&#125;void solve(int l,int r,int L,int R)&#123; if(l&gt;r) return; if(L==R)&#123; up(i,l,r) if(q[i].opt==2) ans[q[i].id]=L; return; &#125; int mid=(L+R)&gt;&gt;1,ta(0),tb(0); clean[1]=1; delt[1]=tr[1]=0; //清空线段树 up(i,l,r)&#123; if(q[i].opt==1)&#123; if(q[i].k&lt;=mid) stack[++ta][0]=q[i]; else insert(1,1,n,q[i].x,q[i].y),stack[++tb][1]=q[i]; &#125;else&#123; ll temp=ask(1,1,n,q[i].x,q[i].y); if(temp&lt;q[i].k) q[i].k-=temp,stack[++ta][0]=q[i]; else stack[++tb][1]=q[i]; &#125; &#125; up(i,1,ta) q[i+l-1]=stack[i][0]; up(i,1,tb) q[i+l+ta-1]=stack[i][1]; solve(l,l+ta-1,L,mid); solve(l+ta,r,mid+1,R);&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); init(); solve(1,m,-INF,INF); up(i,1,cnt) printf("%lld\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>bzoj</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bzoj1901】Dynamic Rankings]]></title>
    <url>%2F2017%2F02%2F25%2F1901%2F</url>
    <content type="text"><![CDATA[本文为博主原创，未经许可不得转载 AC通道 题解这是一个整体二分的板子用树状数组维护单点修改和区间求和即可 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define FILE "read"#define MAXN 500010#define INF 1000000000//#define up(i,j,n) for(int i=j;i&lt;=n;++i)//#define dn(i,j,n) for(int i=j;i&gt;=n;--i)#define cmax(a,b) a=max(a,b)#define cmin(a,b) a=min(a,b)struct node&#123;int x,y,k,cur,id,type;&#125;q[MAXN],stack[MAXN][2];int n,m,cnt,num,data[MAXN],ans[MAXN],tr[MAXN],temp[MAXN];namespace INIT&#123; char buf[1&lt;&lt;15],*fs,*ft; inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,1,1&lt;&lt;15,stdin),fs==ft))?0:*fs++;&#125; inline int read()&#123; int x=0,f=1; char ch=getchar(); while(!isdigit(ch)) &#123;if(ch=='-') f=-1; ch=getchar();&#125; while(isdigit(ch)) &#123;x=x*10+ch-'0'; ch=getchar();&#125; return x*f; &#125;&#125;using namespace INIT;void add(int x,int v)&#123;while(x&lt;=n)tr[x]+=v,x+=(x&amp;-x);&#125;int get(int x)&#123;int sum(0);while(x)sum+=tr[x],x-=(x&amp;-x);return sum;&#125;void init()&#123; up(i,1,n) data[i]=read(),q[++num]=(node)&#123;i,data[i],0,0,0,1&#125;; up(i,1,m)&#123; char ch[3]; scanf("%s",ch+1); if(ch[1]=='Q')&#123; int x=read(),y=read(),k=read(); q[++num]=(node)&#123;x,y,k,0,++cnt,3&#125;; &#125; else&#123; int x=read(),v=read(); q[++num]=(node)&#123;x,data[x],0,0,0,2&#125;; q[++num]=(node)&#123;x,v,0,0,0,1&#125;; data[x]=v; &#125; &#125;&#125;void solve(int l,int r,int L,int R)&#123; if(l&gt;r) return; if(L==R)&#123; up(i,l,r) if(q[i].type==3) ans[q[i].id]=L; return; &#125; int mid=(L+R)&gt;&gt;1,ta(0),tb(0); up(i,l,r)&#123; if(q[i].y&lt;=mid&amp;&amp;q[i].type==1) add(q[i].x,1); if(q[i].y&lt;=mid&amp;&amp;q[i].type==2) add(q[i].x,-1); if(q[i].type==3) temp[i]=get(q[i].y)-get(q[i].x-1); &#125; up(i,l,r)&#123; if(q[i].y&lt;=mid&amp;&amp;q[i].type==1) add(q[i].x,-1); if(q[i].y&lt;=mid&amp;&amp;q[i].type==2) add(q[i].x,1); &#125; up(i,l,r)&#123; if(q[i].type==3)&#123; if(q[i].cur+temp[i]&gt;=q[i].k) stack[++ta][0]=q[i]; else q[i].cur+=temp[i],stack[++tb][1]=q[i]; &#125; else&#123; if(q[i].y&lt;=mid) stack[++ta][0]=q[i]; else stack[++tb][1]=q[i]; &#125; &#125; up(i,1,ta) q[i+l-1]=stack[i][0]; up(i,1,tb) q[i+l+ta-1]=stack[i][1]; solve(l,l+ta-1,L,mid); solve(l+ta,r,mid+1,R);&#125;void pre()&#123; cnt=num=0;&#125;int main()&#123; freopen(FILE".in","r",stdin); freopen(FILE".out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; pre(); init(); solve(1,num,0,INF); up(i,1,cnt) printf("%d\n",ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>bzoj</tag>
        <tag>树状数组</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
</search>
